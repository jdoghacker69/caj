/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * Copyright (c) 2023 STMicroelectronics.
 * All rights reserved.
 *
 * This software is licensed under terms that can be found in the LICENSE file
 * in the root directory of this software component.
 * If no LICENSE file comes with this software, it is provided AS-IS.
 *
 ******************************************************************************
 */


#define MAX_BUFFER_LENGTH 100

#include <stdint.h>
#include <stdlib.h>
#include <stdio.h>
#include <string.h>

#include "serial.h"
#include "movement.h"


#include "stm32f303xc.h"

volatile uint8_t input_received_flag = 0;
volatile uint8_t received_string[MAX_BUFFER_LENGTH];
volatile uint32_t string_index = 0;


#if !defined(__SOFT_FP__) && defined(__ARM_FP)
#warning "FPU is not initialized, but the project is compiling for an FPU. Please initialize the FPU before use."
#endif

//  Function to check if input is the command "start"
int is_start_command(char *input);
// Optional visual delay after transmission
void finished_transmission(uint32_t bytes_sent) {
    for (volatile uint32_t i = 0; i < 0x3ffff; i++) { }
}


void ShapeDemo();
void read_write_start(void);
const int NUMBER_OF_SHAPES = 16;


int main(void)
{
	char *string_to_send = "I'm on a roll!\r\n";
	SerialInitialise(BAUD_115200, &USART1_PORT, &finished_transmission);
	SerialOutputString((char *)"sup bitch ass \r\n", &USART1_PORT);
	read_write_start();


	//void (*completion_function)(uint32_t) = &finished_transmission;

	ShapeDemo();

	/* Loop forever */
	for(;;) {
		SerialOutputString(string_to_send, &USART1_PORT);
	}
}


void ShapeDemo(void) {

	struct shape shape_1 = generate_shape(SHAPE_SPHERE, 5, 5);
	struct shape shape_2;
	struct shape *shape_3;

	struct shape shape_array[16];

	uint8_t string_buffer[64];

	shape_string(&shape_1, &string_buffer[0]);
	SerialOutputString(&string_buffer[0], &USART1_PORT);

	shape_string(&shape_2, &string_buffer[0]);
	SerialOutputString(&string_buffer[0], &USART1_PORT);

	shape_3 = (struct shape*)malloc(sizeof(struct shape));
	shape_string(shape_3, &string_buffer[0]);
	SerialOutputString(&string_buffer[0], &USART1_PORT);

	*shape_3 = generate_shape(SHAPE_CONE, 6,3);
	shape_string(shape_3, &string_buffer[0]);
	SerialOutputString(&string_buffer[0], &USART1_PORT);


	for (uint32_t counter = 0; counter < NUMBER_OF_SHAPES; counter++) {
		if (initialise_shape(&shape_array[counter], counter % 3, 3, 4)) {
			shape_string(&shape_array[counter], &string_buffer[0]);
			SerialOutputString(&string_buffer[0], &USART1_PORT);
		} else {
			shape_string(&shape_array[counter], &string_buffer[0]);
			SerialOutputString(&string_buffer[0], &USART1_PORT);
		}
	}

	// slide the shapes
	sprintf(&string_buffer[0], "sliding the shapes by 1.5 units\r\n");
	SerialOutputString(&string_buffer[0], &USART1_PORT);

	for (uint32_t counter = 0; counter < NUMBER_OF_SHAPES; counter++) {
		slide_shape(&shape_array[counter], 1.5);
		shape_string(&shape_array[counter], &string_buffer[0]);
		SerialOutputString(&string_buffer[0], &USART1_PORT);
	}

	// roll the shapes
	sprintf(&string_buffer[0], "rolling the shapes by 2.5 units\n");
	SerialOutputString(&string_buffer[0], &USART1_PORT);
	for (uint32_t counter = 0; counter < NUMBER_OF_SHAPES; counter++) {
		roll_shape(&shape_array[counter], 2.5);
		shape_string(&shape_array[counter], &string_buffer[0]);
		SerialOutputString(&string_buffer[0], &USART1_PORT);
	}

}







void read_write_start(void) {
while (!input_received_flag){
	while (SerialInputAvailable(&USART1_PORT)) {
        uint8_t c = SerialReadChar(&USART1_PORT);
        if (string_index < MAX_BUFFER_LENGTH - 1) {
            received_string[string_index++] = c;
            if (c == '\n' || c == '\r') {
                received_string[string_index - 1] = '\0'; // null-terminate
                input_received_flag = 1;
            }
        }
        else {
            string_index = 0;

        }
	}

    if (input_received_flag == 1) {
        SerialOutputString((uint8_t *)received_string, &USART1_PORT);
        //  Check if the command is "start" // if not - restart the while loop
        if (is_start_command(received_string) == 1) {
            uint8_t response[] = "\nCommand START received.\n";
            SerialOutputString(response, &USART1_PORT);
            return;
        }
        // Reset
        string_index = 0;
        input_received_flag = 0;

        for (uint32_t i = 0; i < MAX_BUFFER_LENGTH; i++) {
       	received_string[i] = 0;
        }
    }
}
}

